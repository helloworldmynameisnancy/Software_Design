Please keep all files related to a homework or an assignment within the appropriate directory. Files checked in outside of specific homework or assignment directory will not be reviewed or graded for that homework/assignment.

Check in and modify files as many times as you like. You will not be able to modify the files after the deadline.

You will work as a pair, both of you are responsible for the completed work in all assignments and homework. Reasonable effort is expected from each person. If you do not check in, you will not receive any scores. When pairing please switch who checks in so there is significant number of check in from each of you.

The deadlines are strict, there will be no extensions. Don't email any code to Venkat or to the mailing list. Your last check in before the deadline will be graded. If your last check in breaks the code, both you and your pair will lose significant points.

Please feel free to ask for frequent reviews. See the reviews/readme.txt file for details on how to ask for reviews.

You can evolve the answers and solutions based on the reviews. Only the latest checkin at the time of review will be looked at. Also the final check in will be the only one graded.

You are still responsible to successfully complete an homework or assignment even if your pair is a no-show. You can request to change pairs at any time and if there is another person in the class willing to pair with you we can make the switch.

A lot of help will be provided in this course, but you have to start early and ask for help along the way.                                          

Please read the academic honesty policy posted on the course mailing list.                   

The above details apply to all homework and assignments in this course.                   

Now to homework #1.
==============================================================================
HW1: Due 11:59PM CT January 31

1.
Inheritance is a powerful concept, but is also one of the most misused concepts in OOP. Give an example where inheritance is a reasonable choice.
Explain why you think it is a good choice in your example. Then give an example where delegation rather than inheritance is a better choice.
Again explain why you think it is a good choice in your example. Feel free to use any language you like for your examples.

a.
An instance where inheritance is a reasonable choice is when you’re trying to model something x that has similar traits to and can also be reasonably described as another thing y. 
For example, you can have a Vehicle superclass, and from that have different types of vehicles have subclasses, like a Supercar or an Electric car. All of these classes should implement things like 
speed, fuel, and methods to drive/stop/turn, but some things like numeric values (maxFuel, maxSpeed), can differ between the subclasses.
Explain why you think it is a good choice in your example. 
Since some aspects of electric and supercars differ (fueling method, engine) differ and some are the same (maxSpeed, maxFuel) it’s reasonable to describe BOTH electric and supercars as a common 
Vehicle, with some differences. Inheritance allows us to reduce duplicate code while also expressing those differences.


2.
Collectively as a team, mention some of the design smells you have seen in code you have either written or looked at (written by someone else on projects you have worked on). Mention the smell, write a short description about it, and write the consequences (the drawbacks) of that smell. Please list at least five smells.

a.
Bad variable names include single letter variable names and non-descriptive function names. This makes it harder to understand the code and as a result, harder to maintain.

b.
Long functions are functions that have too many tasks, operations, and attributes. Drawbacks include difficulty to interpret, maintain, and reuse code. Having longer functions also increases the chance of unforeseen bugs.

c. 
Repetitive code can be seen where two functions have similar or identical code. This makes the code harder to maintain, because if you need to change code in one function you may need to change code in another function.

d.
Functions that depend too heavily on multiple different subclasses/instances with lots of states are hard to write unit/integration tests for, since you have to write additional tests for every “branch” of failure/success for that singular function. Business functions should be composed on top of each other, so when one fails the others should too.

e.
Objects with only public fields and methods sound good and fun in theory, but in the real world fail the principle of encapsulation and make code less maintainable over time as some developers may rely on things that are public that shouldn’t be, and that can’t be changed later.


















